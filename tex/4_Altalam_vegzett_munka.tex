\chapter{Általam változtatott programok}\label{chap:altalam_valtoztatott_programok}

\section{JavaScriptAddon változások}

\noindent


A séma változtatás után, magát a NodeAddonGenerator fájlt nem módosítottam.
Ennek ellenére a JavaScriptAddon mérete lényegesen megnőtt, mivel a séma nagy bővítésen esett át.
A JavaScript-es nyelvi elemek mellett a TypeScript-es nyelvi elemek is megtalálhatóak benne.
Emiatt sokkal több node, és hozzájuk a wrapper-ek generálódtak le.
A JavaScript-es nyelvi elemek megmaradtak, néhány helyen még javítottunk hibákat is.

\section{JSAN2Lim Bővítések}

\noindent

A JSAN tud már TypeScript fájlokat és projekteket is elemezni, emiatt a JSAN2Lim-et is fejleszteni kellett.
A JSAN2Lim használja a JavaScript és a Lim asg fájlokat egyaránt.

Több helyen is át kellett írni a JSAN2Lim-et:
\begin{itemize}
      \item Több visitor-nál a várt paraméter típusát átírni, például Class-ról ClassDeclarationBase-re, mivel a sémában már nem Class-ként, hanem ClassDeclarationBase-ként szerepel.
      \item Több visitor-nál a várt paraméternél helyét meg kellett változtatni egyes node-nál.
      Például a RestElement eddig a Statement package-en belül helyezkedett el, de a bővítés során átkerült a Parameter package-be.
      \item A Pattern, mint node, Parameter-re lett átnevezve. A helye is megváltozott, Statement package-ből átkerült a Parameter package-be.
      \item Típus lekérdezésnél a \texttt{getIsClass} helyett \texttt{getIsClassDeclarationBase} kellett használni.
\end{itemize}

A bővítések, hogy mikkel bővítettem a JSAN2Lim-et:
\begin{itemize}
      \item Több kind-ot is létrehoztunk a sémában, ezekkel bővíteni kellett a JSAN2Lim-et.
      \item Új node visitor-ok írása. Mint például a TSEnumDeclaration, TSImportEqualsDeclaration, TSInterFaceDeclaration, és még TypeScript node amihez kell visitor.
      A visitor-hoz a fillData függvényeket is megírni.
      \item JSAN2Lim-ben a kindStrings tömb kiegészítése TypeScript-es node-okkal.
      \item Hibák kijavítása, a VariableDeclaration-nél nem detektálta az összes változó deklarálást, főleg metódusokon belül.
      \item A \texttt{getLimKind} metódus bővítése \texttt{getIsTSTypeAliasDeclaration}, \texttt{getIsTSInterfaceDeclaration},
      \texttt{getIsTSAbstractMethodDefinition} és \texttt{getIsTSAbstractPropertyDefinition} esetekkel.
      \item TSEmptyBodyFunctionExpression osztály hibajavítása, hiszen több helyen is leállt a program emiatt.
\end{itemize}

\section{Ast binder optimalizálás}

\noindent

Az AST binder referencia kötésekre (továbbiakban: bindolásra) alkalmas. Ezek a referenciák a JSAN2Lim programhoz szükségesek.
Binder néven van definiálva a metódus a JSAN-ban.
Kétszer van használva, ezért is kulcsfontosságú, hogy gyors legyen.
Egyszer VariableUsages referenciákat bindol és egyszer ACG referenciákat bindol.

\noindent

A binder 4 argumentumot vár:
\todoi{ACG megnézése, hogy mit rövidít}
\begin{itemize}
      \item Egy stringet, ami lehet vagy VariableUsages (továbbiakban: VU) vagy ACG (egy javascript callgraph).
      \item Abstract Syntax Tree-t (továbbiakban: AST), ami egyedien van felépítve.
      \item Egy tömböt, amiben JSON objektumok találhatóak, amik a linkeket tartalmazzák.
      \item Végül még egy stringet, ami lehet addCalls, vagy setRefersTo. Az AddCalls és a SetRefersTo a JavaScriptAddon-ban található meg és onnan hívódik meg.
      Abban az esetben kap addCalls értéket, ha ACG referenciákat bindol a binder, és akkor setRefersTo, ha VU referenciákat.
\end{itemize}

A linkeket tartalmó tömb egy JSON objektuma a következőképpen néz ki:

\begin{lstlisting}[caption={Binder JSON objektuma}, label={lst:binder_json_arg}, language={JavaScript}]
source: {
      label: IdentifierNeve,
      file: AbsPath,
      start: { row: <int>, column: <int>},
      end: { row: <int>, column: <int>},
      range: { start: <int>, end: <int>},
      node: [Object]
},
target: {...}
\end{lstlisting}

Ilyen JSON elemekből épül fel a tömb.
A source és a target objektum felépítése ugyanaz, csak másak az értékek.
A kódrészletben a source van kifejtve bővebben.
A \texttt{label} az egy Identifier vagy PrivateIdentifier node nevét fogja jelölni.
A \texttt{file} egy abszolút útvonalat kap, ami az Identifiert tartalmazó fájlt jelöli.
A \texttt{start} az egy objektum, amiben külön van sor és oszlop meghatározva. Ez az Identifier első karakter pozíciójának a sor és oszlop értékei.
Az \texttt{end} ugyanaz, mint a \texttt{start}, csak itt az utolsó karakter pozíciójának a sor és oszlop értékei.
A \texttt{range} is egy objektum, a start ennél a kezdő karakter hanyadik karakter volt a kódban, és az end pedig az Identifier utolsó karakterének a karakterszáma.
A \texttt{node} is egy objektum ami maga az Identifier vagy PrivateIdentifier.

\subsection{Lassúság okai}

Binder-nek a futási ideje lényegesen megnő, ha nagyonn projektekre futtatjuk le.
Ennek több oka is van:

\begin{itemize}
      \item Minden node hívásnál meghívja a JavaScriptAddon-ból egy metódust.
      A JavaScriptAddon már magában nagy terjedelmű fájl. TypeScript támogatás után kétszeresére nőtt a mérete, mint ezelőtt, emiatt lassult is.
      \item Nagyobb projektekben több függvényhívás és változószám található az elemzett kódban.
      \item Az AST nagyobb projekteknél nagyon nagy is lehet.
      Ezt az AST-t bejárjuk többször is bindolás alatt. Emiatt lesz nagyon lassú a binder.
      \item A JSON objektumokat tartalmazó tömb is nagy méretű lesz, de ez kevésbé lassítja a bindert, mint az AST-s bejárás.
\end{itemize}

\subsection{Optimalizálás}

\noindent

Először ki kellett derítenem, pontosan melyik funkció mennyi memóriát vesz igénybe és milyen gyorsan fut le.
Erre találtam egy javascript profilert, ami kiírta minden függvényhívásnál a lefoglalt memóriát és a memória használatot.
Ez nekem nem volt a legjobb, mivel nagyon egybe van ágyazva minden, és eléggé mélyre mentek a functionok.
Ezután próbáltam picit egyszerűbbet, a binder kódját 3 részre osztani, ${console.time()}$ és ${console.timeEnd()}$ használatával.
Ez a ${console.time()}$ parancs kiírja nekem ms-ben, hogy mennyi idő telt el amíg eljutott a ${console.timeEnd()}$ig.
Így megkaptam, hogy melyik rész nagyjából mennyi idő alatt fut le, könnyebb volt szűkíteni, hogy melyik function lesz a bajos.
Végül kiderült, hogy a következő sor lassítja be nagyon a programot:

\begin{lstlisting}[caption={Problémás function}, label={lst:binder_problemas_function}, language={JavaScript}]
globals.getWrapperOfNode(resolveNode(astSet, sourceFile, element.source.range.start, element.source.range.end, true));
\end{lstlisting}

Ezen belül is a resolveNode function volt a probléma.
A resolveNode kapott egy ast-t (amit a binder kapott meg paraméterbe), egy filenevet, kezdő- és végPozíciót, illetve egy true vagy false értéket, ami attól függ, hogy sourcenodeot vagy targetnodeot keresünk.
Az ast-n forEach-el végigmentünk, amin belül az astNodeon walkoltunk addig amíg nem találtuk meg a számunkra megfelelő nodeot.
Rosszabb esetben a legvégén volt a node, mivel már a végén voltunk a bindolásnak, és ebből is látható volt, hogy ez kellően sok időbe is kerülhet, ha rengeteg nodeunk van.
Kisebb projekt esetében ez nem baj, mivel az ast abban az esetben nem annyira nagy.
Ahol már van 100 vagy 200 ezer változó és vagy függvényhívás, ott már nagyobb a baj, mivel ezt rengetegszer meg kell ismételni.
Ezután ötleteltem, hogy hogyan tudnám jobbra átírni a resolveNodeot functiont, vagy egy másik logika alapján megközelíteni a problémát.
Végül eszembe jutott egy sokkal könnyebb megoldás erre, ami nem igényli a sokszori bejárását az astnek.
\noindent

Először is, létrehoztam egy indexAST nevű functiont, ami a következőket hajtja végre:

\begin{lstlisting}[caption={indexAST function}, label={lst:indexAST_function}, language={JavaScript}]
let indexAST = function (ast) {
      ast.forEach(astNode =>{
            globals.setActualFile(astNode.filename)
            walk(astNode, {
                  enter: function(node){
                  globals.setIndexed(astNode.filename, node.range[0], node.range[1], node)}})})
      return globals.indexedAST}
\end{lstlisting}

\Aref{lst:indexAST_function} kódrészletben látható, hogy egy ast-t várunk paraméterben. Ezt a bindertől fogja kapni, ez az egyénilég létrehozott ast.
A functionben forEach-el végig megyünk az ast elemein, amik az astNodeok. Itt beállítjuk a ${globals.setActualFile()}$ függvénnyel az aktuális filenevet.
Ezután az adott astNode-on elkezdünk walkolni. Csak az enter metódusát írtam meg. Meghívunk egy függvényt ami a globalsban lett definiálva, setIndexed a neve.
Ennek a függvénynek megadjuk a filevenet, a node rangenek a kezdő- és a végparaméterét (tehát ahol kezdődik az adott node és hol végződik, karakterpontosan), és magát a nodeot.

\begin{lstlisting}[caption={setIndexed function}, label={lst:setIndexed_function}, language={JavaScript}]
const setIndexed = function(filename, range_start, range_end, node){
      let actualfilename = getFilePathAlt(filename)
      if (indexedAST[actualfilename + "-" + range_start + "-" + range_end] !== undefined && indexedAST[actualfilename + "-" + range_start + "-" + range_end] !== node){
            return
      }
      indexedAST[actualfilename + "-" + range_start + "-" + range_end] = node
}
\end{lstlisting}

A setIndexed először végez egy vizsgálatot arra, hogy az adott node be van már indexelve.
Ezt úgy teszi meg, hogy az indexedAST tömbben keres egy indexre (Ez az index a következőképp néz ki: fileNev-StartPosition-Endposition), és még vizsgál is arra, hogy ha van ilyen index, akkor ezen van emár olyan node.
Ha van akkor nem állít be semmit, csak returnol, mivel már be van indexelve az adott node. Ha nincs, akkor beállítja az indexedAST tömbnek az adott indexre az adott nodeot.

\noindent

Ezáltal az adott astn csupán csak egyszer megyünk végig foreach-el és egyszer walkolunk, ekkor egy tömbbe beindelexünk minden egyes létező nodeot ami kellhet nekünk.
Ha ezzel megvoltunk akkor utána kezdődhet a binder része.
\Aref{lst:binder_problemas_function} látható, hogy először megkerestük a nodeot index alapján és aztán hívtuk meg rá a ${getWrapperOfNode()}$ függvényt.
Ezt is megváltoztattam, írtam rá egy getIndexed függvényt.
A ${getIndexed()}$ függvény megvizsgálja, hogy source vagy targetNodeot keresünk. Ha targetNodeot, akkor returnoljuk a ${getWrapperOfNode(indexedAST[filename-StartPosition-Endposition])}$-t.
Ha targetNodeot keresünk, akkor walkolunk ismét, de nem az ast-ben, hanem már a beindexelt tömbben.
Ez lényegesen gyorsabb, mint a resolveNodeos megoldás, mert ott minden egyes esetben az ast-n walkoltunk, itt meg csak egy beindexelt elemén a tömbnek.
Ha megkaptuk a sourceNodeot akkor returnoljuk a ${getWrapperOfNode(result)}$t.
