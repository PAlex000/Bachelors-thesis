\chapter{AST Binder Optimalizálás}\label{chap:AST Binder Optimalizálás}

\section{A binderről}

\noindent

Az AST binder referenciákat bindol. Ezek a referenciák a JSAN2Lim programhoz kellenek.
Binder néven van definiálva az astTransformer.js fileban.
Kétszer van használva, ezért is kulcsfontosságú, hogy gyors legyen.
Egyszer VariableUsages referenciákat bindol és egyszer ACG referenciákat bindol.

\noindent

A binder 4 argumentumot vár:

\begin{itemize}
      \item Egy stringet, ami lehet vagy VU (ami VariableUsages-t rövidíti) vagy ACG (egy javascript callgraph).
      \item Egy Abstract Syntax Tree-t (AST), ami egyedien van felépítve.
      \item Egy tömböt, amiben JSON objektumok találhatóak, amik a linkeket tartalmazzák.
      \item Végül még egy stringet, ami lehet addCalls, vagy setRefersTo. Az AddCalls és a SetRefersTo a javascriptAddonban található meg és onnan hívódik meg.
      Akkor addCalls ha ACG referenciákat bindolunk és akkor setRefersTo ha VU referenciákat.
\end{itemize}

A linkeket tartalmó tömb egyik JSON objektuma a következőképp néz ki:

\begin{lstlisting}[caption={Binder JSON argumentuma}, label={lst:binder_json_arg}, language={JavaScript}]
source: {
      label: IdentifierNeve,
      file: AbsPath,
      start: { row: <int>, column: <int>},
      end: { row: <int>, column: <int>},
      range: { start: <int>, end: <int>},
      node: [Object]
},
target: {...}
\end{lstlisting}

\Aref{lst:binder_json_arg} kódrészletben egy JSON elemét láthatjuk a tömbnek. Ilyen JSON elemekből épül fel a tömb.
A source és a target felépítése ugyanaz, csupán másak az értékek bennük.
A kódrészletben csak a sourcet fejtettem ki kicsit bővebben. A label az egy Identifier vagy PrivateIdentifier nevét fogja jelölni.
A file egy abszolút útvonalat, ami az Identifiert tartalmazó filet jelöli.
A start az egy object, amiben külön van sor és oszlop meghatározva. Ez az Identifier első karakter pozíciójának a sor és oszlop értékei.
Az end ugyanaz, mint a start, csak itt az utolsó karakter pozíciójának a sor és oszlop értékei.
A range is egy object, a start ennél a kezdő karakter hanyadik karakter volt a kódban, és az end pedig az identifier utolsó karakterének a karakterszáma.
A node is egy object ami maga az Identifier vagy PrivateIdentifier.

\section{Lassúság okai}

A binder nagyobb projektekre lassan fut le. Ennek több oka is van:

\begin{itemize}
      \item Minden hívásnál meghívja a javascriptAddon.nodeot, ami már magában nagy file. TypeScript támogatás után kétszeres lett a mérete, ezáltal sokkal lassabb lett.
      \item Mivel nagyobb a projekt, ezért sokkal több a függvényhívás is az elemzett kódban, emellett sok a változószám is.
      \item Az AST nagyon nagy, és ezt bejárjuk többször is bindolás alatt. Emiatt nagyon lassú a program nagy projektek esetén.
      \item A JSONokat tartalmazó tömb is nagyon nagy lesz, de annyira ez nem lassítja le a programot.
\end{itemize}

\section{Optimalizálás}

\noindent

Először ki kellett derítenem, pontosan melyik funkció mennyi memóriát vesz igénybe és milyen gyorsan fut le.
Erre találtam egy javascript profilert, ami kiírta minden függvényhívásnál a lefoglalt memóriát és a memória használatot.
Ez nekem nem volt a legjobb, mivel nagyon egybe van ágyazva minden, és eléggé mélyre mentek a functionok.
Ezután próbáltam picit egyszerűbbet, a binder kódját 3 részre osztani, ${console.time()}$ és ${console.timeEnd()}$ használatával.
Ez a ${console.time()}$ parancs kiírja nekem ms-ben, hogy mennyi idő telt el amíg eljutott a ${console.timeEnd()}$ig.
Így megkaptam, hogy melyik rész nagyjából mennyi idő alatt fut le, könnyebb volt szűkíteni, hogy melyik function lesz a bajos.
Végül kiderült, hogy a következő sor lassítja be nagyon a programot:

\begin{lstlisting}[caption={Problémás function}, label={lst:binder_problemas_function}, language={JavaScript}]
globals.getWrapperOfNode(resolveNode(astSet, sourceFile, element.source.range.start, element.source.range.end, true));
\end{lstlisting}

Ezen belül is a resolveNode function volt a probléma.
A resolveNode kapott egy ast-t (amit a binder kapott meg paraméterbe), egy filenevet, kezdő- és végPozíciót, illetve egy true vagy false értéket, ami attól függ, hogy sourcenodeot vagy targetnodeot keresünk.
Az ast-n forEach-el végigmentünk, amin belül az astNodeon walkoltunk addig amíg nem találtuk meg a számunkra megfelelő nodeot.
Rosszabb esetben a legvégén volt a node, mivel már a végén voltunk a bindolásnak, és ebből is látható volt, hogy ez kellően sok időbe is kerülhet, ha rengeteg nodeunk van.
Kisebb projekt esetében ez nem baj, mivel az ast abban az esetben nem annyira nagy.
Ahol már van 100 vagy 200 ezer változó és vagy függvényhívás, ott már nagyobb a baj, mivel ezt rengetegszer meg kell ismételni.
Ezután ötleteltem, hogy hogyan tudnám jobbra átírni a resolveNodeot functiont, vagy egy másik logika alapján megközelíteni a problémát.
Végül eszembe jutott egy sokkal könnyebb megoldás erre, ami nem igényli a sokszori bejárását az astnek.
\noindent

Először is, létrehoztam egy indexAST nevű functiont, ami a következőket hajtja végre:

\begin{lstlisting}[caption={indexAST function}, label={lst:indexAST_function}, language={JavaScript}]
let indexAST = function (ast) {
      ast.forEach(astNode =>{
            globals.setActualFile(astNode.filename)
            walk(astNode, {
                  enter: function(node){
                  globals.setIndexed(astNode.filename, node.range[0], node.range[1], node)}})})
      return globals.indexedAST}
\end{lstlisting}

\Aref{lst:indexAST_function} kódrészletben látható, hogy egy ast-t várunk paraméterben. Ezt a bindertől fogja kapni, ez az egyénilég létrehozott ast.
A functionben forEach-el végig megyünk az ast elemein, amik az astNodeok. Itt beállítjuk a ${globals.setActualFile()}$ függvénnyel az aktuális filenevet.
Ezután az adott astNode-on elkezdünk walkolni. Csak az enter metódusát írtam meg. Meghívunk egy függvényt ami a globalsban lett definiálva, setIndexed a neve.
Ennek a függvénynek megadjuk a filevenet, a node rangenek a kezdő- és a végparaméterét (tehát ahol kezdődik az adott node és hol végződik, karakterpontosan), és magát a nodeot.

\begin{lstlisting}[caption={setIndexed function}, label={lst:setIndexed_function}, language={JavaScript}]
const setIndexed = function(filename, range_start, range_end, node){
      let actualfilename = getFilePathAlt(filename)
      if (indexedAST[actualfilename + "-" + range_start + "-" + range_end] !== undefined && indexedAST[actualfilename + "-" + range_start + "-" + range_end] !== node){
            return
      }
      indexedAST[actualfilename + "-" + range_start + "-" + range_end] = node
}
\end{lstlisting}

A setIndexed először végez egy vizsgálatot arra, hogy az adott node be van már indexelve.
Ezt úgy teszi meg, hogy az indexedAST tömbben keres egy indexre (Ez az index a következőképp néz ki: fileNev-StartPosition-Endposition), és még vizsgál is arra, hogy ha van ilyen index, akkor ezen van emár olyan node.
Ha van akkor nem állít be semmit, csak returnol, mivel már be van indexelve az adott node. Ha nincs, akkor beállítja az indexedAST tömbnek az adott indexre az adott nodeot.

\noindent

Ezáltal az adott astn csupán csak egyszer megyünk végig foreach-el és egyszer walkolunk, ekkor egy tömbbe beindelexünk minden egyes létező nodeot ami kellhet nekünk.
Ha ezzel megvoltunk akkor utána kezdődhet a binder része.
\Aref{lst:binder_problemas_function} látható, hogy először megkerestük a nodeot index alapján és aztán hívtuk meg rá a ${getWrapperOfNode()}$ függvényt.
Ezt is megváltoztattam, írtam rá egy getIndexed függvényt.
A ${getIndexed()}$ függvény megvizsgálja, hogy source vagy targetNodeot keresünk. Ha targetNodeot, akkor returnoljuk a ${getWrapperOfNode(indexedAST[filename-StartPosition-Endposition])}$-t.
Ha targetNodeot keresünk, akkor walkolunk ismét, de nem az ast-ben, hanem már a beindexelt tömbben.
Ez lényegesen gyorsabb, mint a resolveNodeos megoldás, mert ott minden egyes esetben az ast-n walkoltunk, itt meg csak egy beindexelt elemén a tömbnek.
Ha megkaptuk a sourceNodeot akkor returnoljuk a ${getWrapperOfNode(result)}$t.
