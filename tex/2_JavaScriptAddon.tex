\chapter{JavaScriptAddon}\label{chap:JavaScriptAddon}

\section{JavaScriptAddonról}

\noindent

A JavaScriptAddon az egy node kiterjesztésű file, amit a SchemaGenerator generál. Minden egyes nodenak külön generál nodeWrapperheader és egy nodeWrapperCC filet.
A SchemaGenerator által generált Factory.cc, Factory.h és az összes nodeWrapper.cc és a hozzátartozó nodeWrapper.h fileok összemergelése eredményezi a javascriptAddon.node filet.
A SchemaGenerator a JavaScriptSchemából és az ebből generált asgből generálja le a javascriptAddon.node filet.
A SchemaGeneratornak több generálása is definiálva van, hiszen nem csak erre használják. Nekünk a NodeAddonGenerator.c fileban és a hozzátartozó header fileban van minden.
A main.c-be ezt beincludeolja, és ennek hívja meg egyes metódusait, ami által elkészül a javascriptAddon.
A következő pár oldalon bemutatnám, hogy a generálás hogyan zajlik.
A SchemaGeneratornak rengeteg kapcsoloja van, köztük a generateNodeAddon is. Ezekre a kapcsolókra vizsgál egyesével, egy nagy if-elseben.
\begin{lstlisting}[caption={SchemaGenerator kapcsoló vizsgálás},label={lst:schemagenerator_argv_genNodeAddon}, language={CStyle}]
else if(!strcmp(argv[i], "-genNodeAddon")){
      options.generateNodeAddon = true;
}
\end{lstlisting}
A kód elején történik meg ez, ha meg van adva paraméternek a genNodeAddon string, akkor az options.generateNodeAddon-t igazra állítja. A default értéke false.
Ezután jóval lentebb miután rengeteg mindent legenerált ami kell alapból is a normális működéshez, vizsgál egyet az options.generateNodeAddon-ra.
Ez látható \aref{lst:schemagenerator_genNodeAddon_check} kódrészleten is. Else ága nincs, szóval semmi nem történik ha nincs megadva a genNodeAddon string a paramétereknél.
\begin{lstlisting}[caption={SchemaGenerator javascriptAddon generálás},label={lst:schemagenerator_genNodeAddon_check}, language={CStyle}]
if(options.generateNodeAddon ){
      debugMessage(0, "Generating Node.JS Addon sources\n");
      if (createAndEnterDirectory(SOURCE_NODE_ADDON_DIR_NAME)) {
      generatePackageJson();
      generateBindingGyp();
      generateAddonCC();
      generateFactoryWrapper();

      if (createAndEnterDirectory("inc")) {
      generateWrapperHeaders();
      leaveDirectory();}
      if(createAndEnterDirectory("src")){
      generateWrapperSources();
      leaveDirectory();}

      leaveDirectory();}
}
\end{lstlisting}

A createAndEnterDirectory metódus annyit csinál, hogy létrehoz egy mappát és chdirrel belelép. Ha az adott mappa már létezik, akkor csak szimplán belelép.
A SOURCE NODE ADDON DIR NAME változó jelen esetben addon értéket fog kapni, hiszen a javascriptAddon dolgai ebbe fognak generálódni.
Miután létrehozta és/vagy belelépett az addon mappába először legenerálja a package.json filet a projekthez.
A package.json fileban beállítja a projektnevét, verziószámát, dependencyket, scripteket és a végén a gypfile kapcsolónak egy true-t beállít.
\begin{lstlisting}[caption={NodeAddonGenerator package.json scripts}, label={lst:nodeAddonGenerator_package_json}, language={CStyle}]
fprintf(f, "    \"rebuild\": \"node-gyp configure && node-gyp rebuild -j 8\",\n");
fprintf(f, "    \"install\": \"node-gyp configure && node-gyp build -j 8\"\n");
\end{lstlisting}
\Aref{lst:nodeAddonGenerator_package_json} kódrészleten látható, hogy majd gyp segítségével fog történni a generálás.

\noindent

Ezután legenerálja a binding.gyp filet.
Ez a file fog felelni azért, hogy a javascriptAddonhoz sikeresen generálódjanak le a wrapperek és azok headerjei. Ha ez megtörtént, utána fogja legenerálni az addonCC-t.
Az addon.cc fileban beimportálja a Factory.h headert, amiben több metódus is megtalálható.
\begin{lstlisting}[caption={Addon.cc Wrapperek includolása}, label={lst:addoncc_wrapper_include}, language{CStyle}]
if (!traversalDescendantBFT(rootNode, generateWrapIncludes, false)) {
      debugMessage(0, " failed\n");
      fclose(f);
      return false;
}
\end{lstlisting}

\Aref{lst:addoncc_wrapper_include} kódrészletben a traversalDescendantBFT metódust egy másik projektből includoltuk.
Ez egy bejárás, ami az összes nodera lefut, és az összes nodera meghív egy metódust, jelen esetben a generateWrapIncludes metódust.
Ez a generateWrapIncludes a nodeAddonGenerator.c fileban van leimplementálva a következőképp:
\begin{lstlisting}[caption={generateWrapIncludes leimplementálása}, label={lst:addoncc_wrapper_includes_implementation}, language{CStyle}]
if(node->type.abstract){
      return true;
}
fprintf(f, "#include \"");
fprintf(f, "inc/%sWrapper.h\"\n", node->name );
return true;
\end{lstlisting}
Először megvizsgálja, hogy az adott node abstract-e, ha nem akkor tovább megy, és az addon.cc-be includolja az adott nodeWrappernek a headerjét.
A node->name lehet például FunctionDeclaration, ClassDeclaration, amik megtalálhatóak az asg fileban.

Ezután ezt a bejárást mégegyszer végrehajtja, de most a wrapperIniteket generálja az addon.cc fileba.
Annyi változtatással, hogy picit mást ír az addon.cc fileba.
\begin{lstlisting}[caption={generateWrapInit leimplementálása}, label={lst:addoncc_wrapper_inits_implementation}, language={CStyle}]
fprintf(f, "  columbus::%s::asg::addon::%sWrapper::Init(env, exports);\n", schemaName, node->name);
\end{lstlisting}

Ha ezek megtörténtek, akkor az addon.cc filet legeneráltuk sikeresen, és így benne találhatóak a wrapperek headerjének includolása és a wrapperek Initjei.

\noindent

Ezután következik egy generateFactoryWrapper hívás.
A generateFactoryWrapperben 2 metódus hivás található, a generateFactoryWrapperHeader és generateFactoryWrapperSource.

\noindent

A generateFactoryWrapperHeader a Factory.h filet generálta le a következőképp:
Először beincludolja az összes nodeWrappernek a headerjét, és utána létrehoz egy Factory osztályt, publikus metódusait, ami Init és Destructor, illetve a private metódusait,
ami a destructor, New, SaveAST, LoadAST, CLear, getRoot és az összes nodeWrapper create metódusa.
Erre azért van szükség, mivel majd a JSAN-ban ezeket a wrappereket fogjuk létrehozni és szerkeszteni.

\noindent

A generateFactoryWrapperSource pedig a Factory.cc filet generálja le.
Ebben a fileban pedig meg van az összes metódus valósítva, ami a headerjében található.
Emellett a Factory Initjének a props változója a következőképp alakul:
\begin{lstlisting}[caption={Factory.cc file}, label={factory_cc}, language={CStyle}]
napi_property_descriptor props [] = {
      DECLARE_NAPI_METHOD("getRoot", getRoot),
      DECLARE_NAPI_METHOD("createCommentWrapper", createCommentWrapper)
      ...}
\end{lstlisting}
DeclareNapiMethodokat hoz létre, az összes nodeWrappernek, ezek majd a JSAN-ban lesznek használatosak.

\noindent

Utolsó lépésként, először az inc mappát majd az src mappát generálja le a SchemaGenerator.
Az inc mappában találhatóak a header fileok egyes wrappereknek, az src mappában maguk a wrapperek vannak megvalósítva.
Minden nodenak hoz létre wrapper filet, és ezekben valósít meg néhány metódust.
Vegyük most egy példának az ExportAllDeclarationt. Létrehoz egy ExportAllDeclarationWrapper.h és egy ExportAllDeclaration.cc filet.
A header fileban létrehoz egy ExportAllDeclarationWrapper osztályt, ami származik a BaseWrapperből. A BaseWrapper az egy alap Wrapper osztály, amit bővíteni fogunk.
Három publikos metódust generál, Init, Destructor és a NewInstancet.
Ezen felül több private metódust is.
\begin{lstlisting}[caption={ExportAllDeclaration.h file}, label={lst:ExportAllDeclaration_header}, language={CStyle}]
napi_property_descriptor props [] = {
      static napi_value setPosition(...);
      static napi_value addAssertions(...);
      static napi_value setType(...);
...}
\end{lstlisting}

Látható \aref{lst:ExportAllDeclaration_header} kódrészleten, hogy létrehozott az ExportAllDeclarationWrappernek egy setPosition, addAssertions, setType és még több metódust.
Ezek az ExportAllDeclaration attribútumai, amit a JavaScriptSchemában beállítottunk.
\Aref{fig:declaration_vpp} látható, hogy az ExportAllDeclaration hasAssertions attribútumának a multiplicitása 1..*, ezt átkonvertálta addAssertionsre.
Ahol 0..* a multiplicitás, azt átkonvertálta setAttribute-ra, pl setSource vagy setExportedre.
Minden nodeWrappernek van olyan metódusa, hogy setPath, setPosition, setType, addComments, hiszen minden a BaseNode vagy a BaseTokenből öröklődik le.

\noindent

Az ExportAllDeclaration.cc fileban ugyanaz történik, mint ami volt a Factory.cc fileban. Declare napi methodokat generál, a setExported, setSource, setType és a többi metódushoz.
Ezután az összes metódust megvalósítja.

\section{JavaScriptAddon változások}

\noindent

A JavaScriptSchema változtatások után, a NodeAddonGeneratort nem módosítottuk.
Ennek ellenére a javascriptAddon.node mérete megduplázódott, csupán azért, mert a schéma ekkora bővítésen esett át.
Sokkal több nodeWrapper lett, mivel bejöttek a typescript általi dolgok is a javascript mellett.
Természetesen a javascriptes dolgok megmaradtak, így javascriptet ugyanolyan jól tud elemezni, sőt néhány esetben jobban is, mert voltak figyelmetlenségek előző verzióban.

\noindent

Mivel a javascriptAddon mérete nőtt, ezáltal a sebesség csökkent.
Ezt majd egy másik fejezetben jobban kifejtem, célunk az volt, hogy először tudjon typescriptes fileokat és projekteket elemezni a jsan.
