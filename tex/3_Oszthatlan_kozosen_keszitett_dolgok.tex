\chapter{Oszthatlan közösen készített programok}\label{chap:oszthatlan_kozos_dolgok}

\section{A nyelvi séma átírása}

% Sajnos dokumentáció nem készült az előző filehoz, ezért nekünk kellett kitalálni, hogy mi mit csinált, hiszen akik ezt írták, ők már nem foglalkoztak ezzel és elérhetetlenek voltak.
% A szerkesztéshez szükséges volt a Visual Paradigm alkalmazást használni.
% Ezzel egyikőnk sem találkozott még, szóval először ezt kellett tanulmányozni, megérteni.
% Ezután értelmezni kellett a meglévő schemát, hiszen eddig az jól működött, csak nem lehetett könnyen bővíteni.
% Mérlegeltük a két opciót, ahol vagy megpróbáljuk bővíteni a jelenlegi schémát, vagy nulláról elkezdjük újraírni.
% Végül az újraírás mellett döntöttünk, hiszen ezt láttuk gyorsabb és könnyebb megoldásnak. Egy könnyen bővíthető, dokumentál schema volt az elképzelés.
% Ketten fejlesztettük le végül ezt a schemát.
\noindent

Az eddigi JavaScript nyelvi séma (továbbiakban: séma), ami csak javascript nyelvű projekteket és fájlokat elemzett, a javascript hivatalos oldala$^{~\cite{javascript}}$ alapján készült.
\Aref{chap:nyelvi_sema} fejezetben ami ábrák láthatóak, azok már az átírt sémából lettek kifotózva.

\noindent

A séma átírásánál arra a döntésre jutottunk, hogy elölről kezdjük az egészet.
Átláthatatlan volt az előző séma, és nem volt hozzá megfelelő dokumentáció, ezért a bővítés nehezebbnek bizonyult, mint az újraírás a kezdetekről.
Továbbá, egy séma ami képes TypeScript fájlokat és projekteket elemezni, az képes JavaScript fájlokat és projekteket is.
A Base package-et emeltük át az előző sémából, BaseNode-al és BaseToken-el kibővítve. Ez látható \aref{fig:base_vpp} ábrán is.
A TypeScript-eslint github$^{~\cite{typescript-eslint}}$ alapján hoztuk létre a struktúrális felépítést,
annyi változtatással, hogy mi hoztunk létre még egy structure nevű package-et, amiben azok az osztályok találhatóak meg, amelyek a TypeScript-eslint github base mappájában voltak.
Fejlesztés során dokumentáltuk a lépések nagy részét.

\noindent

Minden egymásra épül a sémában, emiatt a műkődést nem tudtuk az elején letesztelni, csak miután több package is készen lett.
Megfigyelhető \aref{lst:asg_file_export_all_declaration} kódrészleten, hogy az ExportAllDeclaration több mindenből öröklődik és sok attribútuma van.
Az ExportAllDeclaration egyik attribútumának a típusa az ImportAttribute.
Ehhez az ImportAttribute osztályt is le kellett fejleszteni a sémában.

\begin{lstlisting}[caption={ImportAttribute},label={lst:asg_file_import_attribute}, language={JavaScript}]
export interface ImportAttribute extends BaseNode {
      type: AST_NODE_TYPES.ImportAttribute;
      key: Identifier | Literal;
      value: Literal;
}
\end{lstlisting}

Az ImportAttributet lefejlesztéséhez le kell fejleszteni az Identifiert, és a Literalt is.
Ezek lefejlesztéséhez is kellett más-más osztályokat lefejleszteni.

\noindent

\section{Nehézségek, problémák}

\noindent

A séma újból írása során több nehézségbe ütköztünk.
Dokumentáció hiánya miatt nem tudtuk az előző sémának minden részét jól értelmezni, néhány félreértés volt fejlesztés közben.
Fejlesztés végén, miután az összes package és osztály le volt fejlesztve, próbáltuk tesztelni.
Tesztelés során Segmentation Fault hibát kapott a program, és nem tudtunk rájönni, hogy miért történik ez.
Emiatt az egész sémát átnéztük, biztosra mentünk, hogy az osztályok öröklődési jól voltak a sémában lefejlesztve, illetve az összes attribútumot is ellenőriztük.
Több kisebb figyelmetlenséget is észrevettünk, és javítottuk.
Több javítás után, újra próbáltunk tesztelni. Ebben az esetben egy másik, jobban beazonosítható hibát kaptunk futtatás során.
Már nem kaptunk Segmentation Fault hibát, hanem futás közben egy node-nál minden hibaüzenet nélkül leállt a program.
Kiderítettük, hogy melyik node-nál áll le a program mindig, ez volt maga a Literal node.
Ismét átnéztük a LiteralExpression osztályt, mivel ez maga a Literal, és egy rossz osztályból öröklődött le, ez okozta a program leállását.
Javítottuk a problémát, és ezek után hibamentesen és jól letudtuk futtatni.

\noindent

Továbbá sok nyelvi elemet a TypeScriptben nem ismertünk.
Tanulmányozni kellett jobban a TypeScript programozási nyelvet, hogy tesztek átnézése során tudjuk mit elemzett le jól és mit nem.
